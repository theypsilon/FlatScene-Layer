24/03/2008 6:47

Existe un error en el dibujado del PJ. Lo soluciono añadiéndole un desplazamiento de medio tile arriba y a la derecha a la hora de dibujarlo en el Piso.
No creo que tenga que ver con los puntos de control.

He dejado a medio revisar el dibujado de los tiles. Quizás esto esté implicado en lo de antes.


27/03/2008 1:32

Definitivamente el error, era que se dibujaba todo 16 pixels más hacia la izquierda y arriba de como debía. Lo soluciono por el momento con un glTranslatef.
Tengo que seguir buscando una solución real, y de paso comprobar si efectivamente en el caso del PJ es el desplazamiento exactamente 16 pixels o un
valor diferente en función del tamaño del sprite.

Tambien estoy comprobando los valores de los límites del mapa que toma la camara.


28/03/2008 5:19

No he seguido con el error del dibujado. Pero he arreglado para cualquier cámara posible el problema de los límites.

Viendo que necesitaba para introducir tiles rectangulares, he necesitado modificar la estructura del mapa, y por lo tanto del editor hecho en Fenix.
He metido 8 variables auxiliares enteras y otras 8 para cadenas de 16 caracteres en la estructura del mapa, para usarlas si las necesito. Convertí
todos los mapas viejos al nuevo formato, pero es posible que hiciese mal la conversión, ya que la realicé tomando "saux" como String en vez de
como char[15] (EDIT: los he reconvertido correctamente por si acaso). 

Al cargar los nuevos mapas en Preliminary, he observado que con 4 cámaras se ve una línea blanca en la cámara inferior-derecha. Puede que sea
causa de la mala conversión. He de seguir investigarlo. EDIT: Ocurre en el mapa 3 y el 7, si pones una cámara encima se arregla, no tiene pinta de
ser culpa del archivo del mapa...

Tengo que adaptar el Rpgtiledemo de Fenix a la nueva estructura del mapa.

De las variables auxiliares tengo pensado coger 2 enteros para las dimensiones del Tile, y 1 cadena para escribir en cada mapa la versión del editor
que se ha usado para crearlo (firma).


03/04/08 0:55

Arreglado lo de la línea blanca. El método putFoto llamado desde CTestEventHandler lo producía. Dicho método ya no tiene sentido con OpenGL.

Incorrecta visualización de los PJs cuando ambos estan en el mismo mapa y se llegan a los extremos.


04/04/08 1:15

No he tocado lo del error de los PJs. 

Cambiado el manejo de las durezas para que tengan encuenta los flags (Ahora no son Uint16, si no TileBG). Las surfaces de durezas ahora son de
12 bits, y los colores de las durezas que existian están calibrados para tal efecto. 


04/04/08 14:37

Arreglado lo del dibujado de los PJs al sustutuir el dibujado en función de su m_Coordxy por m_Scrollxy.

Lo siguiente es continuar adaptando la cámara a distintos tamaños de tiles y a que el centro del objetivo pueda ser variable e incluso no puntual 
(un rectángulo, un círculo...).

Observado cuelgue al acceder a pisos.dat a través del mapa7.dat entrando al gate pegado a la parez izquierda mientras andaba en diagonal izq-abajo. 
No he podido repetirlo.


05/04/08 1:12

Cámara totalmente lista, a falta de retocar detalles. He visto que con un margen de desplazamiento de 64 en el mapa3 se ve un cambio brusco de los
tiles visibles, que por un momento quedan erróneos (con 32 de margen no sucede).

No he podido arreglar aún lo del cuelgue, he visto que al menos llega a cargar en memoria el siguiente mapa antes de que pete el programa (y de que
se muestre por pantalla).


09/04/08  4:48

<<<<<<< HEAD
Objeto CImg retocado. Ahora tiene un manejo más standard con el método get, y add, siendo el array dinámico 'set' privado.
=======
Objeto Img retocado. Ahora tiene un manejo mï¿½s standard con el mï¿½todo get, y add, siendo el array dinï¿½mico 'set' privado.
>>>>>>> bab4376... CImg to Img

Se incluye los esbozos de un zoom para la cámara. Para ello, cambio el texture wrap y el texture filter (min y mag).


10/04/08 6:49

Ahora por defecto estará todo escalado al doble, usando así una resolución de 640x480 en vez de 320x240. El escalado lo hace OpenGL, y el factor
es la constante ESCALADO_BASE. Así las transformaciones glScalef y glRotatef no dañan tanto los sprites, pero aún así persiste cuando hay 
movimiento un molesto tembleque que habrá que corregir.

He retocado el manejo de los obstaculos por parte del PJ para que pueda cambiar de capa, tal y como pasaba en la versión de Fenix. Lo he hecho de
forma chapucera, hay que optimizarlo un rato largo.

El editor de mapas ahora permite brochas y deshacer/rehacer (CTRL+Z / CTRL+Y).

Intenté preparar un nuevo mapa con tiles descargados de internet, pero parece que hay un fallo en el editor cuando se crea un mapa nuevo. Habrá que
investigarlo, tiene pinta de ser por la memoria reservada adicional que metí el otro dia.

Ocurría un error al cambiar de mapa por gate al mismo mapa, ahora se comprueba si el mapa destino es el mismo en el que estamos para evitarlo.

Ya no me ocurre el error del gate del mapa7 ¿lo habré arreglado sin querer? 


22/04/08 4:01

Introducción de ESCALADO_SURFACE (escalado previo por software de la textura al introducirla al sistema). Hay que adaptar los demás parametros
para dejarla operativa.


28/04/08 1:41

ESCALADO_SURFACE no es necesario, ya que lo he simplificado para que el reescalado previo por software se haga en función de ESCALADO_BASE.
En su lugar, está PREESCALADO_BASE, que al definirse indica que siempre que sea posible se usará el reescalado previo por software. Al usar esta
técnica, perdemos un 16% de framerate, pero obtenemos un buen resultado si usamos filtros lineares para las texturas (conserva el Pixel Art al zoom 1.0).
Por tanto, para GL_NEAREST y derivados no tiene sentido activar el preescalado. El preescalado nunca actúa para ficheros que tienen el modo
ONLY_SDL_SURFACE, como es el caso de las durezas. Otra desventaja del preescalado es que ocupa mucha más memoria en el sistema, cada textura
ocupa memoriaoriginal*4^(ESCALADO_BASE-1).

Hay algún desbarajuste en la cámara, ya que con ESCALADO_BASE 2, al ir del mapa1.dat a pisos.dat la escena empieza desplazada a la izquierda (antes
no pasaba, y no se que he cambiado para que pase). Otro detalle raro, esque si desactivamos el límite de FPS, en la esquina superior derecha se ve algo 
raro parpadear.


2/05/08 3:00

Normalizado los objetos globales CMultiverse y Img. Lo mismo para la clase CAction, que ahora hereda de CNode. Prototipo de estrucutura de arbol de nodos
en xml (archivo "actiontree.xml"), y primeros pasos para interpretarla y generar el grafo de acciones. Se ha cambiado el funcionamiento de la lectura de las
acciones en los personajes, habilitando la posibilidad directa de repetir la accion anterior, guardando en memoria el anterior mensaje mandado al PJ y la
anterior acción ejecutada. Se ha reescrito el código de cambiado de mapa, siendo ahora acorde al funcionamiento definitivo de CMultiverse y mucho más compacto.
Aunque se pierde la posibilidad de transformar el mapa, para ahorrarnos eliminar y crear uno nuevo (esto se guardo en una backup).

Se ha guardado la backup(4), y se han insertados mejores textos de comentarios para el cambio de mapa. 

El desbarajuste de la cámara he descubierto que se produce por haber cambiado el momento del movimiento del PJ durante la fase de cambio de mapa:
p->m_Scrollxy.set(g.destino_scroll_x,g.destino_scroll_y,g.destino_scroll_z);	Si se pone al final, tal y como estaba antes no ocurre ese desajuste, pero segun
la lógica de esa implementación es erróneo y puede causar otros fallos. Hay que hacer algo para que la cámara se ajuste tras cambiar de mapa y con setear
los parámetros CX() y CY() a -1000 una vez que la cámara carga un mapa, luego se ajusta solo.


3/05/08 22:38

He avanzado en la lógica de gestión de las acciones, pasando por la lista de acciones candidatas. He establecido una serie de conceptos teóricos que creo
que describen todas los tipos de combinaciones de acciones posibles.

Post Transformación : Cuando una acción en su ejecución modifica directamente el puntero actActual|actUltimo, y la estructura LastMsg. Esto ocasionará un cambio
de acción sin que haya que recurrir al grafo de acciones, lista de candidatos, o a la fase de empezar nueva acción. Esta transformación no es fruto de una simple
pulsación de teclas, normalmente viene determinada por algún requerimiento temporal (actActual->elapsed(int lapso)). Ej: Transformación de Andar a Correr.

Transformación In-Situ: Cuando en la lista de acciones candidatas nos encontramos con que 2 o más acciones de encima de la lista tienen la misma prioridad,
ejecutamos el método combina de la primera acción, pasándole por referencia las demás que tienen la misma prioridad. Este método se encargaría de devolver
una acción consecuente adecuada, que no se encontraba en la lista de acciones candidatas pero que sería el elegido para comenzar ser el nuevo actActual.
Ej: A+B = Doble Acción.    arriba + derecha = diagonal arriba-derecha.

Combo Secuencial: Cuando quieres que cada fase del combo tenga un comportamiento no-instantáneo, y que la ejecución del combo consista en lograr el timing
correcto que coincida con la sucesión entre dichas fases. Para ello, los nodos deben ir enlazados por la función getKeyDown(int i), y el orden de Prioridad de la
sucesión debe tener orden DESCENDENTE. Cada acción no debe ser borrada con getKeyUp(int i), sino por ella misma al final de su ejecución, cuando ha expirado
su timing particular  (como en las acciones de golpes simples). Ej: Combo Ataque Básico + Ataque Básico + Ataque Fuerte.

Combo Instantáneo: Cuando quieres que tu combo sólo sea simplemente una combinación rápida de teclas, en la que sólo tiene protagonismo la acción que se
realiza tras la última pulsación. Para ello, los nodos deben ir enlazados por la función getKeyDown(int i), y el orden de Prioridad de la sucesión debe tener orden 
ASCENDENTE. Cada acción debe borrar a su predecesora y borrarse a si misma si ha expirado su timing particular. Las acciones también pueden ser borradas
(salvo la última) por getKeyUp(int i) si la combinación así lo requiere. Ej: abajo + diagonal alante-abajo + alante + puñetazo = Hayuken.

Combo Secuencial Híbrido: Quieres el mismo comportamiento que el Combo Secuencial pero con un control del timing menos estricto. En el Combo Secuencial
en la primera acción debes pulsar el botón que enlace a la siguiente acción y sólo ese. Si pulsas el boton de la segunda acción, y antes de que termine la primera
acción, pulsas el boton de la tercera acción, este último botón será ignorado. Con este método puedes hacer la combinación igual de rápida que en el Combo
Instantáneo, pero tener el resultado del Combo Secuencial, el problema esque no se puede garantizar que se haya pulsado el orden correcto. Para ello, sólo hay
que usar la misma mecánica del Combo Secuencial, con la diferencia de que cada nodo debe tener añadido en getKeyDown(in i) a TODOS sus sucesores y no
sólo al inmediato. Para evitar que se salte una acción, en cada ejecución se debe comprobar que (actActual!=actUltimo && actActual->getPredecesor()!=actUltimo)
sea falso. Para evitar el problema del posible desorden, se podría modificar el método use() de dichas acciones. Dicho método usaría algún objeto que
almacenase el orden y verificase luego si es correcto o no.

Aparte de la Secuencia de Acciones ya implementada, habría que implementar una Secuencia Auxiliar que se encargaría de ejecutar algunas 'acciones' de
fondo como aquellas que afecten al estado del personaje o su relación con el entorno. Ej: pulsa A para hablar con un NPC, mientras estás haciendo otras acciones
normales.

Para dar versatilidad, he añadido las siguientes variables privadas a CPlayer (posiblemente quede mejor en CActor) que acompañan a actActual: actUltimo,
actUltimoMovimiento, actNeutro.


4/05/08 4:24

Implementada clase CGarbageCollectorOfActions que hereda de CGarbageCollector preparada para contener todos los objetos de Acciones a los que ya no tendrá
acceso directo la clase CPlayer, una vez que esté implementado correctamente el CActionGraph. Entonces, CActionGraph devolverá un NUEVO objeto 
CGarbageCollectorOfActions tras la llamada al método createGarbageCollector(), y se ha de tener la responsabilidad de destuirlo cuando no sea necesario. En este
caso (CPlayer) será en su destructor.


12/06/08 17:21

Le he quitado un poco de tiempo a los examenes para depurar parte del código. Definitivamente he quitado todo soporte al código previo a meter OpenGL.
Debido a esto, he simplificado la jerarquía Canvas-Image-Sprite, eliminando Canvas. Ahora Canvas sólo es una clase estática para que contiene algunos algoritmos.
Esto ha causado que MainCanvas también cambie, funcionando de igualmodo como una clase estática (es más lógico así), y siendo renombrada. Ahora se llama
Screen. También he definido algunos tipos para enmascarar TADs de vectores y listas principalmente.


17/06/08 20:03

'Hostias' y 'Domae Jesu' de Mozart me parecen muy apropiados para copiarlos directamente, y meterlos en el juego. Voy a suspender física.


25/06/08 15:10

He cambiado toda la lógica de la ejecución de la aplicación principal (CApplication). Ahora EventHandler no hereda de CApplication, para crear así una clase
aplicación que pueda tener varias capturas de eventos diferentes. Entonces CTestEventHandler es ahora CTestAGameInterface, dando así a entender que
puede haber otras interfaces de juego totalmente distintas que se encargará de gestionar CApplication. Estudio la posibilidad de dejar CApplication como una
clase meramente estática, pero tendría que solventar el problema del envío de mensajes. La pega es que para ello seguramente requiera una clase adicional,
que a efectos prácticos es lo mismo que lo que tengo ahora.

La nueva clase CApplication ahora asume el rol de gestora de errores, por lo cual la clase InternalError deja de tener sentido y se elimina.


25/06/08 15:10

Refinado el sistema de gestión de errores. Ahora hay un archivo llamado 'errors.log' que guarda todos los incidentes, y se intenta seguir la ejecución hasta que
se colapse el programa del todo (con descomentar una línea, se sale como antes). También hay un nuevo tipo que enumera los tipos de error. Dicho tipo se llama
TypeError.


26/06/08 5:47

Reforzado la parte de la aplicación que interactua con los gestores de eventos de tal modo que detecte si se pretende usar más de un gestor al mismo tiempo (erróneo).
Creada una nueva clase gestora de eventos llamada CFreezeGameInterface que no hace absolutamente nada, pero que ahora es accesible desde 
CTestAGameInterface a través de la tecla ESPACIO. A raiz de esto, he comprobado que existe la necesidad de bloquear los eventos de soltar tecla accesibles desde
el nodo acción activo en todos los jugadores. Para ello he habilitado un método llamado BlockFutureActionCandidates. Esto tiene un pequeño efecto colateral, pero
creo que se le puede pasar totalmente por alto. Simplemente no reaccionan bien algunas de las teclas que siguen pulsadas en el instante de volver al CTestA y estaban 
previamente pulsadas antes de abandonar CTestA, lo cual es anecdótico y se debe seguramente a no haber acciones de Keyup para todas los casos 
(lo cual es un ahorro).


27/06/08 1:42

Para tolerar varias implementaciones de la CTestAGameInterface, he convertido dicha clase en una clase abstracta de la cual heredan CTestA0GameInterface y
<<<<<<< HEAD
CTestA1GameInterface (a la espera de crear más). Mediante la tecla F1 he hecho que ambas hagan una llamada a MSGID_ChangeTest para que se alternen
sin interrumpirse. En todo ese proceso me he dado cuenta de que los objetos globales CMultiverse e CImg ejecutaban dos veces su destructor, lo cual he arreglado. Que
=======
CTestA1GameInterface (a la espera de crear mï¿½s). Mediante la tecla F1 he hecho que ambas hagan una llamada a MSGID_ChangeTest para que se alternen
sin interrumpirse. En todo ese proceso me he dado cuenta de que los objetos globales CMultiverse e Img ejecutaban dos veces su destructor, lo cual he arreglado. Que
>>>>>>> bab4376... CImg to Img
desde el destructor ejecutado al final del programa no se pueda tirar texto por la consola es normal, y no significa q no haya finalicado el destructor correctamente. Se
puede comprobar escribiendo en un fichero externo en lugar de en la consola. Para el soporte del MSGID_ChangeTest he tenido que cambiar la clase
ControlMultiverse, pues el mundo de 2 EventHandler distintos no debe ser compartido. Por ello, ahora se regirá en función de quien administre el mundo (CMultiverse) en ese 
momento y eso se variará con setAdmin.

Ahora adaptaré las clases ControlImages y ControlMultiverse para que trabajen con un mapa y así olvidarme del reciclage.


30/06/08 5:29

<<<<<<< HEAD
He hecho muchísimas cosas desde el anterior mensaje. Brevemente:
·	ControlImages y ControlMultiverse ya trabajan sobre mapas, por lo que ahora será necesario el uso de CImg.remove(int file) para el objeto sepa cuando borrar las 
=======
He hecho muchï¿½simas cosas desde el anterior mensaje. Brevemente:
ï¿½	Images y ControlMultiverse ya trabajan sobre mapas, por lo que ahora serï¿½ necesario el uso de Img.remove(int file) para el objeto sepa cuando borrar las 
>>>>>>> bab4376... CImg to Img
colecciones. 
·	He refinado la mecánica de las acciones, desplazando toda la implementación hacia estas y no hacia el jugador. Por ello, la clase CPlayer ya no ejecuta las acciones 
mediante mensajes, simplemente ejecuta accion->execute() y esta se encarga de modificar el estado de CPlayer. 
·	Para ahorrar comprobaciones innecesarias, aparte de execute(), las acciones constan también de métodos firstExecute y lastExecute que se dedican para esas 
comprobaciones que no hay que hacer más que una vez durante la actividad de la acción. 
·	La clase CAction ahora hereda también de la nueva clase CAnimation, lo que quiere decir que las acciones dirigen también las animaciones internas de los actores.
·	Para la gestión de animaciones he insertado nuevos objetos en 'actiontree.xml'. Entre los cuales destaca el sequence, ya que una animación puede tener varias
secuencias, tal y como se da en el caso del 'pj_normal_quiet'. También he dado pie para que cada step de la secuencia pueda tener varias imágenes, por ello de los
complementos que tengo pensado que pueda seleccionar/deseleccionar para el PJ, aunque aún no está implementado.
·	Existen animaciones genéricas que abarcan distintos ficheros gráficos. Estas son las que llevan el símbolo '*' delante del nombre del fichero. Cuando el programa se
encuentra dichas animaciones, busca la que corresponde al estado actual del actor en el archivo 'animationalias.xml'.
<<<<<<< HEAD
·	Para el desarrollo de todo eso, se han especializado las clases de CAction usando las virtudes de la herencia para ahorrar código.
·	Se ha implementado el objeto Chrono de la clase CTime, el cual regulará apartir de ahora el paso de los frames. Esto significa que ya los intervalos no son de tiempo,
si no de frames. Ese objeto es único en todo el programa y global, como CMultiverse y CImg.
·	Se ha establecido una analogía de los espejados horizontales respecto al punto de control 0, tal y como la establece Fenix.
·	Se ha depurado/eliminado gran cantidad de código,descuidando en cierta medida la encapsulación, ya que realmente no la veo necesaria para este juego.
=======
ï¿½	Para el desarrollo de todo eso, se han especializado las clases de CAction usando las virtudes de la herencia para ahorrar cï¿½digo.
ï¿½	Se ha implementado el objeto Chrono de la clase CTime, el cual regularï¿½ apartir de ahora el paso de los frames. Esto significa que ya los intervalos no son de tiempo,
si no de frames. Ese objeto es ï¿½nico en todo el programa y global, como CMultiverse y Img.
ï¿½	Se ha establecido una analogï¿½a de los espejados horizontales respecto al punto de control 0, tal y como la establece Fenix.
ï¿½	Se ha depurado/eliminado gran cantidad de cï¿½digo,descuidando en cierta medida la encapsulaciï¿½n, ya que realmente no la veo necesaria para este juego.
>>>>>>> bab4376... CImg to Img

Lo siguiente será refinar el dibujado de los actores en la pantalla. Debería ser mediante un método de la clase CActor, que tenga en cuenta todos los sprites que
representen a dicho actor o sus complementos.


02/07/08 7:48

Ayer toqué poco el código. Diferencié finalmente las acciones de movimiento Quiet y Walk, y me di cuenta de que eran dichas acciones las que debían de encargarse de
llamar al método collisionMap, quedando entonces en el método move del Player únicamente una llamada a la ejecución de la acción, y la comprobación de si la acción
ha cambiado respecto al anterior frame. La clase CPlayer quedaría totalmente genérica, a la espera de una posible especialización en el algoritmo de colision, o de la
gestión de Mensajes. 

En CActor he cambiado la variable nameMapa por map, así como los correspondientes métodos que la llaman aprovechando que el otro día me di cuenta de que en c++
se podían hacer ese tipod e cosas. Por ello, ahora tengo que estudiar lo de la clase CObstaculo, pues seguramente ya no haga falta. Debo realizar también un reajuste 
entre las funciones CActor y CPlayer, pues me he dado cuenta de que hay algunas propiedades que deben estar presentes en CActor. 


12/07/08 22:31

Otra tanda de muchas cosas:
-	Todo lo comentado en el reporte inmediatamente anterior se ha realizado. CObstaculo no existe, ahora las durezas las gestiona CMap. El CActor sobre el que trabajan
las acciones se llama ahora 'executor'.
-	Los rectángulos de diferentes durezas de los actores se declaran en el .grd del gráfico correspondiente. Dichos rectángulos se clasifican en áreas, siendo 0 el área de
dureza clásica, 1 la de debilidad, y 2 la de amenaza. Es posible que alguna de estas áreas no tenga ningún rectángulo (se ignorarán), o varios. Las coordenadas de los
rectángulos se especificarán en términos absolutos (respecto al inicio de la celda del sprite), o relativos (respecto el punto de control), aunque luego en el juego se
trabajará siempre respecto con los valores convertidos a relativos, ya que luego se sumarán a las coordenadas del actor en el mapa para poder realizar los cálculos.
-	La rutina de colisiones (tanto con el mapa como con otros actores) se realiza ahora mediante un objeto que hereda de CRutinaColision, para poder tolerar más
flexibilidad. La interpretación de durezas alternativas (azul, amarillo...) aún no está aislada en dicha rutina, y presumiblemente no lo estará, pero aún no está estudiado
dicho aspecto. No obstante dicha rutina si comprueba ya las colisiones con los otros actores gracias a los rectángulos almacenados en el area 0 del sprite actual del
actor. Para ello se creó en el CMap una estructura de datos MA (Matriz de Actores), homóloga a la MO de Fenix. Ella divide cada piso del mapa en celdas que albergan
las listas de los CActor que las ocupan. Quien se encarga de asignar los actores a dicha matriz es el actor, en el metodo que llama a la rutina de colisiones.
-	Breve corrección a la hora de cambiar de mapa. Cuando en una cámara se llama al método ResyncUniverse y el mapa sigue siendo el mismo, las coordenadas de la
cámara no cambian.
-	Se ha creado la clase CEnemy que hereda de CActor, además de las clases CActionWalkAuto0 y CActionQuietAuto0 que heredan de CActionMove para hacer
un test de NPCs, con la idea de comprobar la rapidez de las colisiones. El resultado fue muy gratificante, obtengo 18 FPS+- con 10000 NPCs en pantalla, frente a los
10-15 FPS que obtenía en fenix con 300 NPCs (ambos dejan actuar a los NPCs durante todo el mapa, no solo la franja visible).
-	Para facilitar la creación de CActons en las factorias de CActionMove, CActionFight, etc, se creará un método estático en las clases nuevas llamado
ThisType(const char* ) que evalua si dicha cadena extraida del XML que almacena el arbol de acciones es del tipo de esa implementación.
-	En la lectura de los .grd SpriteSet se han incluido nuevos términos para facilitar su elaboración. El parámetro simple='true' calcula todos los sprites automáticamente
estableciendo su punto de control en 0.0 y extrapolando el ancho y alto de celda al ancho y alto de Sprite. Ideal para los Set de Tiles. El parámetro defined-in="x" provoca
que se copien todos los valores del .grd "x". Esto se hace mediante una recursión a loadChipset, que se regula con una variable auxiliar para que no degenere en un
bucle infinito (globalAuxiliar, definida en 'definitions.h'). Además de estos nuevos atributos para la etiqueta Spriteset, se incluyen nuevas etiquetas: <globalcpoint> la cual
establece el cpoint de todos los sprites en el mismo punto y <globalareas> que hace lo mismo. Las etiquetas <area> y <rectangle> definen las areas como tales (ya sea
de forma global o en cada imagen), es importante tener en cuenta que siempre deben estar definidas todas las areas cuyo id sea inferior a la area con id máximo (osea,
que si existe un área con id 2, debe existir un área con id1 y otra con id0) y que no pueden repetirse.

A falta de algo que se me pueda olvidar eso es todo. Ya que tengo a tiro la capacidad de testear el sistema de ataques gracias a la implementación de las areas y de
los npcs, supongo que será lo próximo que haga.

10/10/08

Estoy generalizando el código para el proyecto fin de carrera. Habrá una clase CUniverse, padre de CMap que será más ambigüa, y será realmente con la que
trabaje la cámara. Por tanto habrá que cambiar el TAD que gestiona los CMap y CCamera, aparte de otros pequeños detalles.

CCamara cambia los siguientes métodos: 

loadMap -> loadUniverse , unloadMap -> unloadUniverse , changeMap -> resyncUniverse.

1/11/08

A falta de algo que se me escape, ya he generalizado todo lo que quería. Ahora por tanto, tengo CMap que hereda de CUniverse y CScrollCamera que hereda de
CCamera. Y CWorld es ahora CMultiverse. A falta de algún detalle que se me escape, eso era todo. Ahora revisaré todo el código en general, a ver si veo algo
raro.